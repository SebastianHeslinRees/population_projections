% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/apply_domestic_migration_rates.R
\name{apply_domestic_migration_rates}
\alias{apply_domestic_migration_rates}
\title{Apply origin-destination migration rates to a population}
\usage{
apply_domestic_migration_rates(
  popn,
  mign_rate,
  col_aggregation = c("year", gss_code = "gss_out", "sex", "age"),
  col_gss_destination = "gss_in",
  col_popn = "popn",
  col_rate = "rate",
  col_flow = "flow",
  one2many = TRUE,
  many2one = FALSE,
  col_origin_destination = NA
)
}
\arguments{
\item{popn}{A data frame containing population data.}

\item{mign_rate}{A data frame containing origin-destination migration at the
same or coarser resolution as \code{popn}. Geographic resolutions must
match, however.}

\item{col_aggregation}{A string or named character vector giving names of
columns in \code{popn} to which the output will be aggregated, and how they
join to columns in \code{mign_rate}. In particular, the mapping from the
population geography to the migration origin geography columns must be
specified, e.g. \code{c("year", "gss_code"="gss_out", "sex", "age")}. The
destination geography and additional aggregation levels not in \code{popn}
are specified in the next parameter. All elements must give columns in
\code{popn} but not all need to be in \code{mign_rate}, (that is,
\code{mign_rate} can be at a coarser resolution). If there is more than one
geographic resolution, only specify the finest resolution common to the
population data frame and the origin-destination data. Default
\code{c("year", "gss_code"="gss_out", "sex", "age")}.}

\item{col_gss_destination}{String or character vector giving names of columns
in \code{mign_rate} to which the output will be aggregated, and which
weren't included in \code{col_aggregation} because \code{popn} doesn't join
to them. This will usually just be \code{mign_rate}'s destination
geographies. If is of length two or more you will need to specify
\code{col_outflow_inflow} below. Default "gss_in".}

\item{col_popn}{String. Name of column in \code{popn} containing population
counts. Default "popn"}

\item{col_rate}{String. Name of column in \code{mign_rate} containing
migration rates. Default "rate"}

\item{col_flow}{String. Name of column to write output flows to. Default
"flow".}

\item{one2many}{Logical. Setting this to FALSE will check that no more than
one level from \code{popn_rate} matches to each level of \code{popn}. Default
TRUE}

\item{many2one}{Logical. Passed to \code{apply_rate_to_population}. Setting to FALSE
will check that no more than one level from \code{popn} matches to each
level of \code{mign_rate}. Default TRUE.}

\item{col_origin_destination}{Character vector. Names of the origin and
destination columns in \code{mign_rate}. Only required when
\code{col_gss_destination} is of length two or more, though providing it
(marginally) speeds things up. The code is able to infer these columns
otherwise. Default NA.}
}
\value{
A data frame of origin-destination flows at the aggregation levels
  provided by \code{col_aggregation}.
}
\description{
Given a cohort population and a data frame of migration rates that can be
joined to the population, return a data frame of origin-destination flows.
}
\details{
The output data frame will use the column names of the migration dataset for
the origin and destination columns (if origin columns differ). This means
that, with default column names, the population's \code{gss_code} column will
be renamed to \code{gss_out}.

The function assumes implicitly missing origin-destination flows are zero. It
permits zero outmigration for an entire aggregation level, and this level
will **not** be included in the output data frame, meaning you may need to
call \code{tidyr::complete} on the results (after aggregation to in/out/net
flows).

The function tries to maintain tibbles, factors and grouping to match the
inputs, with the input population taking precedence when there is a conflict.

The function can't yet handle migration data at a lower geographic resolution than
the population data (e.g. LAD migration on LSOA data), but it's on the to do list!

Despite its fancy appearance, it's really just a little wrapper around
apply_rate_to_population
}
\examples{

popn <- expand.grid(year = 2000,
                    gss_code=c("a","b"),
                    sex=c("female","male"),
                    age=20:21,
                    popn = 100)

mign_rate <- expand.grid(year = 2000,
                         gss_out=c("a","b"),
                         gss_in=c("a","b"),
                         sex=c("female","male"),
                         age=20:21) \%>\%
   dplyr::filter(gss_out != gss_in) \%>\%
   dplyr::mutate(rate = 0.1)

apply_domestic_migration_rates(popn,
                 mign_rate,
                 col_aggregation = c("year", "gss_code"="gss_out", "sex", "age"),
                 col_gss_destination = "gss_in",
                 col_popn = "popn",
                 col_rate = "rate",
                 col_flow = "flow",
                 one2many = FALSE,
                 many2one = TRUE,
                 col_origin_destination = NA)

# equivalent to
apply_domestic_migration_rates(popn, mign_rate)

}
