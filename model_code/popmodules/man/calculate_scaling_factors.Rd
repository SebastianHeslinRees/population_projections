% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/calculate_scaling_factors.R
\name{calculate_scaling_factors}
\alias{calculate_scaling_factors}
\title{Produce scaling factors to convert one population to another}
\usage{
calculate_scaling_factors(
  popn,
  constraint,
  col_aggregation = c("year", "sex", "age", "country"),
  col_popn,
  col_constraint = col_popn,
  rows_to_constrain = TRUE
)
}
\arguments{
\item{popn}{A data frame containing population data.}

\item{constraint}{A data frame containing population data at the same
resolution or lower.}

\item{col_aggregation}{A string or character vector giving the join mapping between
\code{popn} and \code{constraint}. Equivalent to \code{by} in \code{dplyr} joins.}

\item{col_popn}{String. Name of column in \code{popn} containing population
counts.}

\item{col_constraint}{String. Name of column in \code{constraint} containing population
counts. Defaults to the value of \code{col_popn}.}

\item{rows_to_constrain}{Which rows of the input population are to be
constrained. This can be provided as a logical vector (e.g. \code{TRUE} for
all rows or \code{c(TRUE, TRUE, FALSE)} or using dplyr's non-standard
evaluation, e.g. for a population with a \code{gss_code} column,
\code{gss_code == "E090000001"} for City of London, or \code{grepl("^E09",
gss_code)} for all of London. Note this can't be applied to the population
column. Default TRUE.}
}
\value{
A data frame of scaling factors calculated as target population/input population,
  with one row for each level of the input population for each distinct level of the
  input \code{col_aggregation} columns.
}
\description{
Given a cohort population and a data frame of target marginal population
subtotals, return a set of scaling factors which, when applied, will scale
the input population to match the target at each grouping level.
}
