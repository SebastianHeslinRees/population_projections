% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/apply_rate_to_population.R
\name{apply_rate_to_population}
\alias{apply_rate_to_population}
\title{Apply rates to a population.}
\usage{
apply_rate_to_population(
  popn,
  popn_rate,
  col_aggregation = c("year", "gss_code", "sex", "age"),
  col_popn = "popn",
  col_rate = "rate",
  col_out = "component",
  pop1_is_subset = FALSE,
  many2one = TRUE,
  additional_rate_levels = NA,
  missing_levels_popn = FALSE,
  missing_levels_rate = FALSE
)
}
\arguments{
\item{popn}{A data frame containing population data.}

\item{popn_rate}{A data frame containing rates data per time step (usually
year).}

\item{col_aggregation}{A string or character vector giving the names of
columns in \code{popn} which the output will be aggregated to. All elements
must give columns in \code{popn} but not all need to be in
\code{popn_rate}, (that is, \code{popn_rate} can be at a lower resolution).
If names differ between the two input data frames, use a named character
vector, e.g. \code{c("gss_code"="LSOA11CD")}. Default \code{c("year",
"gss_code", "age", "sex")}.}

\item{col_popn}{String. Name of column in \code{popn} containing population
counts. Default "popn".}

\item{col_rate}{String. Name of column in \code{popn_rate} containing rate
data. Default "rate".}

\item{col_out}{String. Name of column for the output component count
(popn*rate) in the output. Default "component".}

\item{pop1_is_subset}{Logical. If the two input data frames cover the same
domain and you expect every level of \code{popn_rate} to be matched to by a
level in \code{popn} set this to TRUE, and this will be checked. Default
FALSE.}

\item{many2one}{Logical. Setting this to FALSE will check that no more than
one level from \code{popn} matches to each level of \code{rate}. Default
FALSE.}

\item{additional_rate_levels}{String. Names of columns in \code{popn_rate}
which should be included in the join beyond those named in
\code{col_aggregation}. Used when multiple rates apply to the same
aggregation level, e.g. outmigration to multiple locations. The resulting
left join with \code{popn_rate} can therefore return a much larger data
frame. Default NA.}

\item{missing_levels_popn}{Logical. Is the popn data frame missing any
levels? Reminder: \code{pop1_is_subset} will probably be TRUE in this case.
Default FALSE.}

\item{missing_levels_rate}{Logical or character vector. Is the rates data
missing any levels? If joining the missing levels to the input population
would create NAs, the missing values in the output column will be NA. Note:
setting this to TRUE will disable some of the checks on the input and join
datasets. Default FALSE.}
}
\value{
A data frame of component counts calculated as input popn * rate, with one row
  for each distinct level of the input \code{col_aggregation} columns.
}
\description{
Given a cohort population and a data frame of rates at the same or lower
resolution, return a data table of the population's aggregation levels, and a
component count resulting from the rate applied to the population.
}
\examples{

popn <- expand.grid(year=2000, age=20:21, gss_code=c("a","b"), sex=c("f","m"), popn = 100)
rate <- expand.grid(year=2000, age=20:21, gss_code=c("a","b"), sex=c("f","m"), rate = 0.5)

component <- apply_rate_to_population(popn,
                             rate,
                             col_aggregation = c("year", "gss_code", "sex", "age"),
                             col_popn = "popn",
                             col_rate = "rate",
                             col_out = "component",
                             pop1_is_subset = FALSE,
                             many2one = TRUE,
                             missing_levels_popn = FALSE,
                             missing_levels_rate = FALSE)

# Due to default parameter values, this is equivalent to
component <- apply_rate_to_population(popn, rate)

}
