% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/popn_constrain.R
\name{popn_constrain}
\alias{popn_constrain}
\title{Scale one population to match the totals of another}
\usage{
popn_constrain(popn, constraint, col_aggregation = c("year", "gss_code",
  "sex", "age"), col_popn = "popn", pop1_is_subset = FALSE,
  missing_levels_popn = FALSE, missing_levels_constraint = FALSE)
}
\arguments{
\item{popn}{A data frame containing population data.}

\item{constraint}{A data frame containing population data at the same
resolution or lower.}

\item{col_aggregation}{A string or character vector giving the names of
columns in \code{popn} contain aggregation levels. All elements
must give columns in \code{popn} but not all need to be in
\code{constraint}, (that is, \code{constraint} can be at a lower resolution).
If names differ between the two input data frames, use a named character
vector, e.g. \code{c("gss_code"="LSOA11CD")}. Default \code{c("year",
"gss_code", "age", "sex")}.}

\item{col_popn}{String. Name of column in \code{popn} containing population
counts. Default "popn".}

\item{pop1_is_subset}{Logical. If the two input data frames cover the same
domain and you expect every level of \code{constraint} to be matched to by a
level in \code{popn} set this to TRUE, and this will be checked. Default
FALSE.}

\item{missing_levels_popn}{Logical. Is the popn data frame missing any
levels? Reminder: \code{pop1_is_subset} will probably be TRUE in this case.
Default FALSE.}

\item{missing_levels_constraint}{Logical or character vector. Is the rates data
missing any levels? If joining the missing levels to the input population
would create NAs, the missing values in the output column will be NA. Note:
setting this to TRUE will disable some of the checks on the input and join
datasets. Default FALSE.}
}
\value{
A data frame of component counts calculated as input popn * rate, with one row
  for each distinct level of the input \code{col_aggregation} columns.
}
\description{
Given a cohort population and a data frame of target marginal population
subtotals, return the input population scaled so that its population
subtotals match the target's at each grouping level.
}
\examples{

library(popmodules)

popn <- expand.grid(year=2000, age=20:21, gss_code=c("a","b"), sex=c("f","m"), popn = 100)
constraint <- expand.grid(year=2000, age=20:21, sex=c("f","m"), popn = 400)

scaled <- popn_constrain(popn,
                         constraint,
                         col_aggregation = c("year", "gss_code", "sex", "age"),
                         col_popn = "popn",
                         pop1_is_subset = FALSE,
                         missing_levels_popn = FALSE,
                         missing_levels_constraint = FALSE)

# Due to default parameter values, this is equivalent to
scaled <- popn_constrain(popn, constraint)

constraint <- expand.grid(xyear=2000, xage=20:21, xsex=c("f","m"), xpopn = 400)

scaled <- popn_constrain(popn,
                         constraint,
                         col_aggregation = c("year"="xyear", "gss_code", "sex"="xsex", "age"="xage"),
                         col_popn = c("popn"="xpopn"),
                         pop1_is_subset = FALSE,
                         missing_levels_popn = FALSE,
                         missing_levels_constraint = FALSE)


}
