% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/validate_population.R
\name{validate_population}
\alias{validate_population}
\title{Validate a population dataset}
\usage{
validate_population(population, col_aggregation = c("year", "gss_code",
  "age", "sex"), col_data = NA, test_complete = TRUE,
  test_unique = TRUE, check_negative_values = TRUE,
  comparison_pop = NA, col_comparison = col_aggregation)
}
\arguments{
\item{population}{A data frame containing population data.}

\item{col_aggregation}{A string or character vector giving column names for
levels of data aggregations: e.g. geographic area, age/age band, sex. It
will be checked that these behave as a primary key. If there is more than
one geography column (e.g. ward code, ward name, or ward code borough code)
include only the highest resolution and only one column. Default value is
columns for "gss_code", "age", "sex".}

\item{col_data}{A string of character vector giving column names for data
(e.g. popn, birth rate). Columns given will be checked for missing and
negative values. Any columns not named in the input are currently ignored.
Default value is NA.}

\item{test_complete}{Logical. Check all combinations of aggregation variables
are present. The test will fail when lower geographic resolutions are
present (e.g. borough and LSOA), so make sure these are not passed to
\code{col_aggregation}. Default TRUE.}

\item{test_unique}{Logical. Check there are no duplicate combinations of any
of the given aggregation levels. Default TRUE.}

\item{check_negative_values}{Logical value requesting data are checked for
negative values. Defaults to TRUE.}

\item{comparison_pop}{Optional. A data frame containing all aggregation
levels of the population being tested (e.g. an initial population), so that
they can be checked to match. Default to NA.}

\item{col_comparison}{A character vector giving the names of the aggregation
levels in the comparison population. If names are different between frames,
provide a named character vector, as you would with by=c() in a join.
Defaults to the value of \code{col_aggregation}, accepts NA.}
}
\value{
The input population, unchanged. Return is invisible, so the function
  can be called within a dplyr pipe or as a one-line validity test
}
\description{
Performs common checks to validate a population dataset. The dataset is
expected to contain at least one 'aggregation' column (e.g. geography, age,
sex), and optionally 'data' columns, (e.g. popn, rate).
}
\details{
The function checks for missing values, duplicated aggregation levels, unused
aggregation levels (optional), negative data values (optional), and validates
the input against a provided 'comparison' input (optional).

Currently the function can only process a single geography column - give it
the highest resolution contained in the data frame. Any columns not named are
ignored.

The function will stop code execution with an error message if it finds a
problem.
}
