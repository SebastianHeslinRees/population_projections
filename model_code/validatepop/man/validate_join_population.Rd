% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/validate_join_population.R
\name{validate_join_population}
\alias{validate_join_population}
\title{Check one population is contained within another}
\usage{
validate_join_population(pop1, pop2,
  cols_common_aggregation = intersect(names(pop1), names(pop2)),
  pop1_is_subset = TRUE, many2one = TRUE, one2many = TRUE)
}
\arguments{
\item{pop1, pop2}{Data frames.}

\item{cols_common_aggregation}{A character vector. Names of columns for
data aggregation common to both input data frames (e.g. age, ward). If
columns don't have the same name, use a named character vector (e.g.
\code{"WARD"="WARD11CD"}). Defaults to column names shared between the
input data frames, but it's best not to use this in case the overlap it
finds is not what you expect.}

\item{pop1_is_subset}{Logical. When TRUE \code{pop1} is allowed to match to
subset of \code{pop2}.When FALSE the aggregation levels should be the same
(ignoring duplicates) and the mapping will be surjective, i.e. all
aggregation levels must be present in both data frames. Default TRUE.}

\item{many2one}{Logical. Can multiple rows in \code{pop1} map to a single row
in \code{pop2}? Set to FALSE when matching should be unique (i.e.
injective), and leave TRUE when, e.g. \code{pop2} has fewer aggregation
levels than code{pop2}, for example when validating a join from LSOA data
to MSOA data on MSOA11CD.}

\item{one2many}{Logical. Can one row in the first population map to several
in the second? Set to FALSE when testing a left join that expects the same
number of rows out. Default TRUE.}
}
\value{
\code{pop1}, invisibly (stopping on failure).
}
\description{
The function checks that every row of one population can be mapped to a row
in another, given common aggregation columns (e.g. age, geography). It is
designed to confirm that joins between population datasets, are going to
behave as you expect, and will throw errors if the mapping between datasets
is ambiguous or incomplete, or doesn't perform according to other optional
restrictions.
}
\details{
By default the function just checks that one population's aggregation levels
are contained within another. The option \code{pop1_is_subset} requires the
levels to match exactly (ignoring duplicates). Turning off \code{one2many}
requires each row in \code{pop1} to map to exactly one level in \code{pop2} -
use this when you expect a left join to return the same number of rows as the
input. Turning off \code{many2one} requires levels in \code{pop2} to map to
at most one level in \code{pop1}, use this when you want to confirm a unique
mapping from \code{pop1} into code{pop2}.

The function does not do a full validation of the population data: use
\code{validate_population} for that.
}
